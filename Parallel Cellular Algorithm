import copy
import random

GRID_WIDTH = 5
GRID_HEIGHT = 5
NUM_ITERATIONS = 4 # You can increase iterations if you want

EMPTY = '.'
CAR = 'C'
PEDESTRIAN = 'P'

# Track blocked agents last step and skip move on alternate steps
skip_move = False

def initialize_population(car_count=5, pedestrian_count=3):
    grid = [[EMPTY for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
    road_rows = [1, 3]
    for _ in range(car_count):
        row = random.choice(road_rows)
        col = random.randint(0, GRID_WIDTH - 1)
        grid[row][col] = CAR
    walkway_rows = [4]
    for _ in range(pedestrian_count):
        row = random.choice(walkway_rows)
        col = random.randint(0, GRID_WIDTH - 1)
        if grid[row][col] == EMPTY:
            grid[row][col] = PEDESTRIAN
    return grid

def count_blocked(grid):
    blocked = 0
    for r in [1, 3]:
        for c in range(GRID_WIDTH):
            if grid[r][c] == CAR:
                next_c = (c + 1) % GRID_WIDTH
                if grid[r][next_c] != EMPTY:
                    blocked += 1
    for r in [4]:
        for c in range(GRID_WIDTH):
            if grid[r][c] == PEDESTRIAN:
                next_r = (r - 1) % GRID_HEIGHT
                if grid[next_r][c] != EMPTY:
                    blocked += 1
    return blocked

def update_states(grid, skip_move):
    new_grid = [[EMPTY for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]

    # Move cars right if possible and if not skipping move step
    for r in range(GRID_HEIGHT):
        for c in range(GRID_WIDTH):
            if grid[r][c] == CAR:
                if skip_move:
                    new_grid[r][c] = CAR  # skip move this turn
                else:
                    next_c = (c + 1) % GRID_WIDTH
                    if grid[r][next_c] == EMPTY:
                        new_grid[r][next_c] = CAR
                    else:
                        new_grid[r][c] = CAR

    # Move pedestrians up if possible and if not skipping move step
    for r in range(GRID_HEIGHT):
        for c in range(GRID_WIDTH):
            if grid[r][c] == PEDESTRIAN:
                if skip_move:
                    new_grid[r][c] = PEDESTRIAN  # skip move this turn
                else:
                    next_r = (r - 1) % GRID_HEIGHT
                    if new_grid[next_r][c] == EMPTY and grid[next_r][c] == EMPTY:
                        new_grid[next_r][c] = PEDESTRIAN
                    else:
                        new_grid[r][c] = PEDESTRIAN

    return new_grid

def print_grid(grid, step, fitness):
    print(f"Step {step} | Blocked Agents: {fitness}")
    for row in grid:
        print(''.join(row))
    print()

def run_simulation():
    global skip_move
    grid = initialize_population()
    best_fitness = float('inf')
    best_grid = None

    for step in range(1, NUM_ITERATIONS + 1):
        fitness = count_blocked(grid)
        if fitness < best_fitness:
            best_fitness = fitness
            best_grid = copy.deepcopy(grid)
        
        print_grid(grid, step, fitness)
        grid = update_states(grid, skip_move)
        skip_move = not skip_move  # alternate between moving and waiting
    
    print("=== Final Best Result ===")
    print(f"Minimum Blocked Agents: {best_fitness}")
    for row in best_grid:
        print(''.join(row))

run_simulation()
